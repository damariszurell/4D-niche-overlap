## Extension of the niche overlap analyses in the R package ecospat
## adapted by D. Zurell (contact: damaris@zurell.de), 
## to allow for multi-dimensional niche estimation using the R package 'ks'.
## implemented in February 2017, last changed November 2017
##
## Reference: Zurell et al. (2018) Do long-distance migratory birds track their niche through seasons? Journal of Biogeography 45: 1459-1468. https://doi.org/10.1111/jbi.13351
##################################################################################################

# I call the ecospat package first so that all dependencies and imported packages are loaded (although the code actually just uses the niche.overlap function from ecospat). I have written a new version of the function for 'ecospat.grid.clim.dyn' called 'grid.clim.hypervolume', and a new version of the function 'ecospat.niche.similarity.test' called 'niche.similarity.test.hypervolume' that work generically for up to 4 data dimensions.

library(ecospat)
library(ks)

grid.clim.hypervol <- function (glob, glob1, sp, R, th.sp = 0, th.env = 0) 
{
    glob <- as.matrix(glob)
    glob1 <- as.matrix(glob1)
    sp <- as.matrix(sp)
    l <- list()
    
    if (ncol(glob) > 4) 
        stop("Calculate overlap with more than four axes is not tested yet; the binning procedure won't work")    
    
 		require(ks)
    	
        xmin <- apply(glob,2,min)
        xmax <- apply(glob,2,max)
        
        gr = R

        grid <- sapply(seq_len(ncol(glob)),FUN=function(x){seq(xmin[x],xmax[x],length=gr)})       	
        glob1r =glob1; spr = sp
             
        sp.dens <- kde(spr,binned=T,bgridsize=rep(gr,ncol(spr)),xmin=xmin,xmax=xmax)$estimate
                      
        z <- sp.dens*nrow(sp)/sum(sp.dens)		#rescale density to the number of occurrences in sp
        
        glob1.dens <- kde(glob1r,binned=T,bgridsize=rep(gr,ncol(glob1r)),xmin=xmin,xmax=xmax)$estimate   
        Z <- glob1.dens*nrow(glob1)/sum(glob1.dens) 		#rescale density to the number of sites in glob1
        
        Z[Z<max(Z)/1000] <- 0 	
		 z[z<max(z)/1000] <- 0 	# remove infinitesimally small number generated by kernel density function
        z[Z==0] <- 0
        
        z.uncor <- z/max(z)	# rescale between [0:1] for comparison with other species
        w <- z.uncor
        w[w > 0] <- 1
        z.cor <- z/Z
        z.cor[is.na(z.cor)] <- 0
        z.cor <- z.cor/max(z.cor)
        l$grid <- grid
        l$z <- z
        l$z.uncor <- z.uncor
        l$z.cor <- z.cor
        l$Z <- Z
        l$glob <- glob
        l$glob1 <- glob1
        l$sp <- sp
        l$w <- w

    return(l)
}


#----------------------------------------------
niche.similarity.test.hypervol <- function (z1, z2, reps, alternative = "greater", rand.type=1) {
    R <- nrow(z1$grid) 
    l <- list()
	if (ncol(z1$grid)>1)  {
		dim.z <- dim(z1$Z)
		shift.center <- function(center,rand.center) {t(apply(rand.center,1,FUN=function(x){x-center}))}
		} else {
			dim.z <- dim(z1$grid)
			coords <- function(x,dim) {x}
			shift.center <- function(center,rand.center) {shift = rand.center[,1]-center[,1]; as.matrix(shift,dim.z)}
			}
    grid.i <- expand.grid(data.frame(matrix(seq_len(nrow(z1$grid)),nrow=nrow(z1$grid),ncol=ncol(z1$grid))))

	obs.o<-ecospat.niche.overlap(z1,z2,cor=T) 								#observed niche overlap
	sim.o<-data.frame(matrix(nrow=reps,ncol=2))						#empty list of random niche overlap
	names(sim.o)<-c("D","I")
	
	center <- arrayInd(which(z2$z.cor==1),dim.z)				# define the centroid of the observed niche
	rand.center <- arrayInd(sample(seq_len(prod(dim.z)),size=reps,prob=z1$Z/max(z1$Z),replace=F),dim.z)			# randomly (weighted by environment prevalence) define the new centroid for the niche
	xshift <- shift.center(center,rand.center)
	
	sim.o1 <- sapply(seq_len(reps),FUN=function(i){
		grid.shift <- grid.i-xshift[i,]
		i.shift <- rowSums(grid.shift < 1 | grid.shift > nrow(z1$grid)) < 1
		z2.sim <- z2	
		z2.sim$z.cor[] <- 0
		z2.sim$z.cor[as.matrix(grid.shift[i.shift,])] <- z2$z.cor[as.matrix(grid.i[i.shift,])]
		z2.sim$z.cor <- (z2$Z!=0)*1*z2.sim$z.cor 					# remove densities out of existing environments
		
		if (sum(z2.sim$z.cor)) ecospat.niche.overlap(z1,z2.sim,cor=T) else list(D=0,I=0)
	})
   	sim.o <- data.frame(D=unlist(sim.o1['D',]),I=unlist(sim.o1['I',]))

    if (rand.type==2) {
        center <- arrayInd(which(z1$z.cor==1),dim.z)				# define the centroid of the observed niche
        rand.center <- arrayInd(sample(seq_len(prod(dim.z)),size=reps,prob=z2$Z/max(z2$Z),replace=F),dim.z)			# randomly (weighted by environment prevalence) define the new centroid for the niche
        xshift <- shift.center(center,rand.center)
        
        sim.o2 <- sapply(seq_len(reps),FUN=function(i){
            grid.shift <- grid.i-xshift[i,]
            i.shift <- rowSums(grid.shift < 1 | grid.shift > nrow(z2$grid)) < 1
            z1.sim <- z1
            z1.sim$z.cor[] <- 0
            z1.sim$z.cor[as.matrix(grid.shift[i.shift,])] <- z1$z.cor[as.matrix(grid.i[i.shift,])]
            z1.sim$z.cor <- (z1$Z!=0)*1*z1.sim$z.cor 					# remove densities out of existing environments
            
            if (sum(z1.sim$z.cor)) ecospat.niche.overlap(z2,z1.sim,cor=T) else list(D=0,I=0)
        })
        sim.o <- rbind(sim.o,data.frame(D=unlist(sim.o2['D',]),I=unlist(sim.o2['I',])))

    }


	l$sim<-sim.o											# storage
	l$obs<-obs.o											# storage

    if (alternative == "greater") {
        l$p.D <- (sum(sim.o$D >= obs.o$D) + 1)/(length(sim.o$D) + 
            1)
        l$p.I <- (sum(sim.o$I >= obs.o$I) + 1)/(length(sim.o$I) + 
            1)
    }
    if (alternative == "lower") {
        l$p.D <- (sum(sim.o$D <= obs.o$D) + 1)/(length(sim.o$D) + 
            1)
        l$p.I <- (sum(sim.o$I <= obs.o$I) + 1)/(length(sim.o$I) + 
            1)
    }

	l$ses.rank.D <- ((sum(obs.o$D > sim.o$D)+1)/(length(sim.o$D)+1)) 	# standardised effect size based on the rank of the observation among simulated values
	l$ses.rank.I <- ((sum(obs.o$I > sim.o$I)+1)/(length(sim.o$I)+1))
	l$ses.z.D <- (obs.o$D - mean(sim.o$D)) / sd(sim.o$D)				# standardised effect size calculated as standardised mean difference between observation and simulated values (the z-score)
	l$ses.z.I <- (obs.o$I - mean(sim.o$I)) / sd(sim.o$I)

	return(l)
}

